#!/usr/bin/env python

import os
import signal
import sys
import optparse
import threading
import time
import pprint
import warnings

import yapsnmp
import sqlalchemy

import essnmp.sql
import tsdb

class ThriftClient(object):
    def __init__(self):
        self.transport = TSocket.TSocket('localhost', 9090)
        self.transport = TTransport.TBufferedTransport(self.transport)
        self.protocol = TBinaryProtocol.TBinaryProtocol(self.transport)
        self.client = ESDB.Client(self.protocol)
        self.transport.open()

class ESPollError(Exception):
    pass

class ESPollUnknownIfIndex(ESPollError):
    pass

class ESPollConfig(object):
    def __init__(self, file):
        self.file = file

        self.db_uri = None
        self.tsdb_root = None

        self.read_config()

    def read_config(self):
        f = open(self.file,"r")
        for line in f:
            line = line.strip()
            if line.startswith("#"):
                continue
            (var, val) = line.split()
            if var == "db_uri":
                self.db_uri = val
            elif var == "tsdb_root":
                self.tsdb_root = val
            else:
                raise ESPollError("unknown config option: %s %s" % (var,val))


def normalize_ifDescr(name):
    """remove troublesome metacharacters from ifDescr"""
    for (char,repl) in (("/", "_"), (" ", "")):
        name = name.replace(char, repl)
    return name

class ESSNMPPollCorrelator(object):
    """polling correlators correlate an ifIndex to some other field.  this is
    typically used to generate the key needed to store the variable."""

    def __init__(self, session=None):
        self.session = session

    def setup(self):
        raise NotImplementedError

    def lookup(self, ifIndex):
        raise NotImplementedError

class ESSNMPIfDescrCorrelator(ESSNMPPollCorrelator):
    """correlates and ifIndex to an it's ifDescr"""

    def setup(self):
        self.xlate = {}
        for (var,val) in self.session.walk("ifDescr"):
            self.xlate[var.split(".")[-1]] = normalize_ifDescr(val)

    def lookup(self, ifIndex):
        try:
            return self.xlate[ifIndex]
        except:
            raise ESPollUnknownIfIndex(ifIndex)

class ESSNMPPollManager(object):
    """Starts a polling process for each device"""

    def __init__(self, opts, args):
        self.opts = opts
        self.args = args
        self.config = ESPollConfig(opts.config_file)

        self.running = False

        self.db_session = sqlalchemy.create_session(essnmp.sql.db)

        self.devices = self.db_session.query(essnmp.sql.Device).select_by(active=True)
        #self.devices = self.db_session.query(essnmp.sql.Device).select_by(name="atla-cr1")

        self.children = {}  # dict maps device name to child pid

        if not tsdb.TSDB.is_tsdb(self.config.tsdb_root):
            tsdb.TSDB.create(self.config.tsdb_root)

    def start_polling(self):
        """Begin polling all routers for all OIDSets"""
        for device in self.devices:
            for oidset in device.oidsets:
                if oidset.name == "IfRefPoll":
                    continue

                exec("poller = %s" % oidset.poller.name)

                name = device.name + "_" + oidset.name
                print name
                pid = os.fork()
                if pid:
                    self.children[name] = pid
                else:
                    poller(self.config, name, device, oidset).run()

        signal.signal(signal.SIGINT, self.stop_polling)
        signal.signal(signal.SIGTERM, self.stop_polling)
        self.running = True

        while self.running:
            #
            # XXX should do a waitpid(0) and check for children who have died
            # and restart
            #
            time.sleep(10)
            print "controller wakes and goes back to sleep"

    def stop_polling(self, signum, frame):
        self.running = False
        for child in self.children:
            pid = self.children[child]
            os.kill(pid, signal.SIGTERM)
            (rpid,status) = os.waitpid(pid, 0)

class Poller(object):
    def __init__(self, config, name, device, oidset):
        self.config = config
        self.name = name
        self.device = device
        self.oidset = oidset

        self.next_poll = int(time.time() - 1)
        self.oids = self.oidset.oids
        self.running = True

        print "connecting to",self.device.name
        self.snmp_session = yapsnmp.Session(self.device.name, version=2,
                community=self.device.community)

        signal.signal(signal.SIGTERM, self.stop)
        signal.signal(signal.SIGHUP, self.reload)

    def run(self):
        raise NotImplementedError("must implement run method")

    def stop(self, signum, frame):
        self.running = False
        print "stopping"

    def reload(self, signum, frame):
        print "if it was implemented, i'd be reloading"

class TSDBPoller(Poller):
    def __init__(self, config, name, device, oidset):
        Poller.__init__(self, config, name, device, oidset)

        # XXX should fix TSDB to allow drilling down
        self.tsdb = tsdb.TSDB(self.config.tsdb_root)
        try:
            self.tsdb_set = self.tsdb.get_set(self.device.name)
        except tsdb.TSDBSetDoesNotExistError:
            self.tsdb_set = self.tsdb.add_set(self.device.name)

        try:
            self.tsdb_set = self.tsdb_set.get_set(self.oidset.name)
        except tsdb.TSDBSetDoesNotExistError:
            self.tsdb_set = self.tsdb_set.add_set(self.oidset.name)

class SQLPoller(Poller):
    pass

class IfRefSQLPoller(SQLPoller):
    """Polls all OIDS and creates a IfRef entry then sees if the IfRef entry
    differs from the lastest in the database."""

    def __init__(self, config, name, device, oidset):
        SQLPoller.__init__(self, config, name, device, oidset)
#
# XXX are the oidset, etc vars burdened with sqlalchemy goo? if so, does it
# matter?
#
class IfDescrCorrelatedTSDBPoller(TSDBPoller):
    """Polls each OID individually, correlates the ifIndex to ifDescr and
    stores the results in the TSDBSet named after the OIDSet in a TSDBVar
    named after the ifDescr."""
    """Handles polling of an OIDSet for a device"""
    def __init__(self, config, name, device, oidset):
        TSDBPoller.__init__(self, config, name, device, oidset)

        self.correlator = ESSNMPIfDescrCorrelator(self.snmp_session)


    def run(self):
        while self.running:
            print time.time(),"hello from",self.name

            self.correlator.setup()
            if time.time() >= self.next_poll:
                print self.name,"grabbing data"
                self.next_poll += self.oidset.frequency
                begin = time.time()
                cnt = 0
                for oid in self.oids:
                    vars = self.snmp_session.walk(oid.name)
                    cnt += len(vars)
                    self.store(oid, vars)
                print self.name,"grabbed %d vars in %f seconds" % (cnt, time.time() - begin)
                print self.name,"next",self.next_poll

            time.sleep(self.next_poll - int(time.time()))

    def store(self, oid, vars):
        ts = time.time()
        # XXX might want to use the ID here instead of expensive exec
        exec("vartype = tsdb.%s" % oid.type.name)

        for (var,val) in vars:
            if oid.name.startswith("if"):
                var = self.correlator.lookup(var.split('.')[-1])

            try:
                tsdb_var = self.tsdb_set.get_var(var)
            except tsdb.TSDBVarDoesNotExistError:
                # XXX should allow the mapper to be configurable
                tsdb_var = self.tsdb_set.add_var(var, vartype,
                        self.oidset.frequency, tsdb.YYYYMMDDChunkMapper) 

            tsdb_var.insert(vartype(ts, tsdb.ROW_VALID, val))
            #print vartype, var, ts, val, vartype.unpack(vartype(ts, tsdb.ROW_VALID, val).pack())

def main(argv):
    oparse = optparse.OptionParser()
    oparse.add_option("-d", "--debug", dest="debug", action="store_true",
            default=False)
    oparse.add_option("-f", "--config-file", dest="config_file", default="./espolld.conf")

    (opts, args) = oparse.parse_args(args=argv)

    poller = ESSNMPPollManager(opts, args)
    poller.start_polling()

if __name__ == "__main__":
    main(sys.argv)
