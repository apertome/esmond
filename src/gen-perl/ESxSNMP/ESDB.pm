#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use ESxSNMP::Types;

# HELPER FUNCTIONS AND STRUCTURES

package ESxSNMP::ESDB_list_devices_args;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_list_devices_args->mk_accessors( qw( active ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{active} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{active}) {
      $self->{active} = $vals->{active};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_list_devices_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{active});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_list_devices_args');
  if (defined $self->{active}) {
    $xfer += $output->writeFieldBegin('active', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{active});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_list_devices_result;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_list_devices_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_list_devices_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size56 = 0;
          $self->{success} = [];
          my $_etype59 = 0;
          $xfer += $input->readListBegin(\$_etype59, \$_size56);
          for (my $_i60 = 0; $_i60 < $_size56; ++$_i60)
          {
            my $elem61 = undef;
            $xfer += $input->readString(\$elem61);
            push(@{$self->{success}},$elem61);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_list_devices_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter62 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter62);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_get_device_args;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_get_device_args->mk_accessors( qw( name ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_get_device_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_get_device_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_get_device_result;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_get_device_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_get_device_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new ESxSNMP::Device();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_get_device_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_get_all_devices_args;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_get_all_devices_args->mk_accessors( qw( active ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{active} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{active}) {
      $self->{active} = $vals->{active};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_get_all_devices_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{active});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_get_all_devices_args');
  if (defined $self->{active}) {
    $xfer += $output->writeFieldBegin('active', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{active});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_get_all_devices_result;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_get_all_devices_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_get_all_devices_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size63 = 0;
          $self->{success} = {};
          my $_ktype64 = 0;
          my $_vtype65 = 0;
          $xfer += $input->readMapBegin(\$_ktype64, \$_vtype65, \$_size63);
          for (my $_i67 = 0; $_i67 < $_size63; ++$_i67)
          {
            my $key68 = '';
            my $val69 = new ESxSNMP::Device();
            $xfer += $input->readString(\$key68);
            $val69 = new ESxSNMP::Device();
            $xfer += $val69->read($input);
            $self->{success}->{$key68} = $val69;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_get_all_devices_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter70,$viter71) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter70);
          $xfer += ${viter71}->write($output);
        }
      }
      $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_add_device_args;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_add_device_args->mk_accessors( qw( name begin_time end_time ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{name} = undef;
$self->{begin_time} = undef;
$self->{end_time} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{begin_time}) {
      $self->{begin_time} = $vals->{begin_time};
    }
    if (defined $vals->{end_time}) {
      $self->{end_time} = $vals->{end_time};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_add_device_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{begin_time});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_time});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_add_device_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{begin_time}) {
    $xfer += $output->writeFieldBegin('begin_time', TType::STRING, 2);
    $xfer += $output->writeString($self->{begin_time});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_time}) {
    $xfer += $output->writeFieldBegin('end_time', TType::STRING, 3);
    $xfer += $output->writeString($self->{end_time});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_add_device_result;
use Class::Accessor;
use base('Class::Accessor');
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
return bless($self,$classname);
}

sub getName {
  return 'ESDB_add_device_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_add_device_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_update_device_args;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_update_device_args->mk_accessors( qw( name begin_time end_time ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{name} = undef;
$self->{begin_time} = undef;
$self->{end_time} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{begin_time}) {
      $self->{begin_time} = $vals->{begin_time};
    }
    if (defined $vals->{end_time}) {
      $self->{end_time} = $vals->{end_time};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_update_device_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{begin_time});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_time});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_update_device_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{begin_time}) {
    $xfer += $output->writeFieldBegin('begin_time', TType::STRING, 2);
    $xfer += $output->writeString($self->{begin_time});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_time}) {
    $xfer += $output->writeFieldBegin('end_time', TType::STRING, 3);
    $xfer += $output->writeString($self->{end_time});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_update_device_result;
use Class::Accessor;
use base('Class::Accessor');
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
return bless($self,$classname);
}

sub getName {
  return 'ESDB_update_device_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_update_device_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_list_device_oidsets_args;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_list_device_oidsets_args->mk_accessors( qw( device ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{device} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{device}) {
      $self->{device} = $vals->{device};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_list_device_oidsets_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{device} = new ESxSNMP::Device();
        $xfer += $self->{device}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_list_device_oidsets_args');
  if (defined $self->{device}) {
    $xfer += $output->writeFieldBegin('device', TType::STRUCT, 1);
    $xfer += $self->{device}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_list_device_oidsets_result;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_list_device_oidsets_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_list_device_oidsets_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size72 = 0;
          $self->{success} = [];
          my $_etype75 = 0;
          $xfer += $input->readListBegin(\$_etype75, \$_size72);
          for (my $_i76 = 0; $_i76 < $_size72; ++$_i76)
          {
            my $elem77 = undef;
            $elem77 = new ESxSNMP::OIDSet();
            $xfer += $elem77->read($input);
            push(@{$self->{success}},$elem77);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_list_device_oidsets_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter78 (@{$self->{success}}) 
        {
          $xfer += ${iter78}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_list_oids_args;
use Class::Accessor;
use base('Class::Accessor');
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
return bless($self,$classname);
}

sub getName {
  return 'ESDB_list_oids_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_list_oids_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_list_oids_result;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_list_oids_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_list_oids_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size79 = 0;
          $self->{success} = [];
          my $_etype82 = 0;
          $xfer += $input->readListBegin(\$_etype82, \$_size79);
          for (my $_i83 = 0; $_i83 < $_size79; ++$_i83)
          {
            my $elem84 = undef;
            $xfer += $input->readString(\$elem84);
            push(@{$self->{success}},$elem84);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_list_oids_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter85 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter85);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_get_oid_args;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_get_oid_args->mk_accessors( qw( name ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_get_oid_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_get_oid_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_get_oid_result;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_get_oid_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_get_oid_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new ESxSNMP::OID();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_get_oid_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_add_oid_args;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_add_oid_args->mk_accessors( qw( name storage oidtype ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{name} = undef;
$self->{storage} = undef;
$self->{oidtype} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{storage}) {
      $self->{storage} = $vals->{storage};
    }
    if (defined $vals->{oidtype}) {
      $self->{oidtype} = $vals->{oidtype};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_add_oid_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{storage});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{oidtype});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_add_oid_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{storage}) {
    $xfer += $output->writeFieldBegin('storage', TType::STRING, 2);
    $xfer += $output->writeString($self->{storage});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{oidtype}) {
    $xfer += $output->writeFieldBegin('oidtype', TType::STRING, 3);
    $xfer += $output->writeString($self->{oidtype});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_add_oid_result;
use Class::Accessor;
use base('Class::Accessor');
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
return bless($self,$classname);
}

sub getName {
  return 'ESDB_add_oid_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_add_oid_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_list_oidsets_args;
use Class::Accessor;
use base('Class::Accessor');
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
return bless($self,$classname);
}

sub getName {
  return 'ESDB_list_oidsets_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_list_oidsets_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_list_oidsets_result;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_list_oidsets_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_list_oidsets_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size86 = 0;
          $self->{success} = [];
          my $_etype89 = 0;
          $xfer += $input->readListBegin(\$_etype89, \$_size86);
          for (my $_i90 = 0; $_i90 < $_size86; ++$_i90)
          {
            my $elem91 = undef;
            $xfer += $input->readString(\$elem91);
            push(@{$self->{success}},$elem91);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_list_oidsets_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter92 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter92);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_get_oidset_args;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_get_oidset_args->mk_accessors( qw( name ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_get_oidset_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_get_oidset_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_get_oidset_result;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_get_oidset_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_get_oidset_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new ESxSNMP::OIDSet();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_get_oidset_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_get_oidset_devices_args;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_get_oidset_devices_args->mk_accessors( qw( oidset ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{oidset} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{oidset}) {
      $self->{oidset} = $vals->{oidset};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_get_oidset_devices_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{oidset} = new ESxSNMP::OIDSet();
        $xfer += $self->{oidset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_get_oidset_devices_args');
  if (defined $self->{oidset}) {
    $xfer += $output->writeFieldBegin('oidset', TType::STRUCT, 1);
    $xfer += $self->{oidset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_get_oidset_devices_result;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_get_oidset_devices_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_get_oidset_devices_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size93 = 0;
          $self->{success} = [];
          my $_etype96 = 0;
          $xfer += $input->readListBegin(\$_etype96, \$_size93);
          for (my $_i97 = 0; $_i97 < $_size93; ++$_i97)
          {
            my $elem98 = undef;
            $elem98 = new ESxSNMP::Device();
            $xfer += $elem98->read($input);
            push(@{$self->{success}},$elem98);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_get_oidset_devices_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter99 (@{$self->{success}}) 
        {
          $xfer += ${iter99}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_get_vars_by_grouping_args;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_get_vars_by_grouping_args->mk_accessors( qw( grouping ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{grouping} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{grouping}) {
      $self->{grouping} = $vals->{grouping};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_get_vars_by_grouping_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{grouping});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_get_vars_by_grouping_args');
  if (defined $self->{grouping}) {
    $xfer += $output->writeFieldBegin('grouping', TType::I32, 1);
    $xfer += $output->writeI32($self->{grouping});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_get_vars_by_grouping_result;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_get_vars_by_grouping_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_get_vars_by_grouping_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new ESxSNMP::VarList();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_get_vars_by_grouping_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_store_poll_result_args;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_store_poll_result_args->mk_accessors( qw( result ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{result} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{result}) {
      $self->{result} = $vals->{result};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_store_poll_result_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^-1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{result} = new ESxSNMP::SNMPPollResult();
        $xfer += $self->{result}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_store_poll_result_args');
  if (defined $self->{result}) {
    $xfer += $output->writeFieldBegin('result', TType::STRUCT, -1);
    $xfer += $self->{result}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_store_poll_result_result;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_store_poll_result_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_store_poll_result_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BYTE) {
        $xfer += $input->readByte(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_store_poll_result_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BYTE, 0);
    $xfer += $output->writeByte($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_select_args;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_select_args->mk_accessors( qw( path begin_time end_time flags cf resolution ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{path} = undef;
$self->{begin_time} = undef;
$self->{end_time} = undef;
$self->{flags} = undef;
$self->{cf} = undef;
$self->{resolution} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
    if (defined $vals->{begin_time}) {
      $self->{begin_time} = $vals->{begin_time};
    }
    if (defined $vals->{end_time}) {
      $self->{end_time} = $vals->{end_time};
    }
    if (defined $vals->{flags}) {
      $self->{flags} = $vals->{flags};
    }
    if (defined $vals->{cf}) {
      $self->{cf} = $vals->{cf};
    }
    if (defined $vals->{resolution}) {
      $self->{resolution} = $vals->{resolution};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_select_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{path});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{begin_time});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_time});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{flags});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cf});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{resolution});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_select_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
    $xfer += $output->writeString($self->{path});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{begin_time}) {
    $xfer += $output->writeFieldBegin('begin_time', TType::STRING, 2);
    $xfer += $output->writeString($self->{begin_time});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_time}) {
    $xfer += $output->writeFieldBegin('end_time', TType::STRING, 3);
    $xfer += $output->writeString($self->{end_time});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{flags}) {
    $xfer += $output->writeFieldBegin('flags', TType::STRING, 4);
    $xfer += $output->writeString($self->{flags});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cf}) {
    $xfer += $output->writeFieldBegin('cf', TType::STRING, 5);
    $xfer += $output->writeString($self->{cf});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{resolution}) {
    $xfer += $output->writeFieldBegin('resolution', TType::STRING, 6);
    $xfer += $output->writeString($self->{resolution});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_select_result;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_select_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{error} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{error}) {
      $self->{error} = $vals->{error};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_select_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new ESxSNMP::VarList();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{error} = new ESxSNMP::ESDBError();
        $xfer += $self->{error}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_select_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{error}) {
    $xfer += $output->writeFieldBegin('error', TType::STRUCT, 1);
    $xfer += $self->{error}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_get_interfaces_args;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_get_interfaces_args->mk_accessors( qw( device all_interfaces ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{device} = undef;
$self->{all_interfaces} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{device}) {
      $self->{device} = $vals->{device};
    }
    if (defined $vals->{all_interfaces}) {
      $self->{all_interfaces} = $vals->{all_interfaces};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_get_interfaces_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{device});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{all_interfaces});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_get_interfaces_args');
  if (defined $self->{device}) {
    $xfer += $output->writeFieldBegin('device', TType::STRING, 1);
    $xfer += $output->writeString($self->{device});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{all_interfaces}) {
    $xfer += $output->writeFieldBegin('all_interfaces', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{all_interfaces});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDB_get_interfaces_result;
use Class::Accessor;
use base('Class::Accessor');
ESxSNMP::ESDB_get_interfaces_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ESDB_get_interfaces_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size100 = 0;
          $self->{success} = [];
          my $_etype103 = 0;
          $xfer += $input->readListBegin(\$_etype103, \$_size100);
          for (my $_i104 = 0; $_i104 < $_size100; ++$_i104)
          {
            my $elem105 = undef;
            $elem105 = new ESxSNMP::IfRef();
            $xfer += $elem105->read($input);
            push(@{$self->{success}},$elem105);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ESDB_get_interfaces_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter106 (@{$self->{success}}) 
        {
          $xfer += ${iter106}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ESxSNMP::ESDBIf;

sub list_devices{
  my $self = shift;
  my $active = shift;

  die 'implement interface';
}
sub get_device{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}
sub get_all_devices{
  my $self = shift;
  my $active = shift;

  die 'implement interface';
}
sub add_device{
  my $self = shift;
  my $name = shift;
  my $begin_time = shift;
  my $end_time = shift;

  die 'implement interface';
}
sub update_device{
  my $self = shift;
  my $name = shift;
  my $begin_time = shift;
  my $end_time = shift;

  die 'implement interface';
}
sub list_device_oidsets{
  my $self = shift;
  my $device = shift;

  die 'implement interface';
}
sub list_oids{
  my $self = shift;

  die 'implement interface';
}
sub get_oid{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}
sub add_oid{
  my $self = shift;
  my $name = shift;
  my $storage = shift;
  my $oidtype = shift;

  die 'implement interface';
}
sub list_oidsets{
  my $self = shift;

  die 'implement interface';
}
sub get_oidset{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}
sub get_oidset_devices{
  my $self = shift;
  my $oidset = shift;

  die 'implement interface';
}
sub get_vars_by_grouping{
  my $self = shift;
  my $grouping = shift;

  die 'implement interface';
}
sub store_poll_result{
  my $self = shift;
  my $result = shift;

  die 'implement interface';
}
sub select{
  my $self = shift;
  my $path = shift;
  my $begin_time = shift;
  my $end_time = shift;
  my $flags = shift;
  my $cf = shift;
  my $resolution = shift;

  die 'implement interface';
}
sub get_interfaces{
  my $self = shift;
  my $device = shift;
  my $all_interfaces = shift;

  die 'implement interface';
}
package ESxSNMP::ESDBRest;

sub new {
  my $classname=shift;
  my $impl     =shift;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub list_devices{
  my $self = shift;
  my $request = shift;

  my $active = ($request->{'active'}) ? $request->{'active'} : undef;
  return $self->{impl}->list_devices($active);
}

sub get_device{
  my $self = shift;
  my $request = shift;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_device($name);
}

sub get_all_devices{
  my $self = shift;
  my $request = shift;

  my $active = ($request->{'active'}) ? $request->{'active'} : undef;
  return $self->{impl}->get_all_devices($active);
}

sub add_device{
  my $self = shift;
  my $request = shift;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $begin_time = ($request->{'begin_time'}) ? $request->{'begin_time'} : undef;
  my $end_time = ($request->{'end_time'}) ? $request->{'end_time'} : undef;
  return $self->{impl}->add_device($name, $begin_time, $end_time);
}

sub update_device{
  my $self = shift;
  my $request = shift;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $begin_time = ($request->{'begin_time'}) ? $request->{'begin_time'} : undef;
  my $end_time = ($request->{'end_time'}) ? $request->{'end_time'} : undef;
  return $self->{impl}->update_device($name, $begin_time, $end_time);
}

sub list_device_oidsets{
  my $self = shift;
  my $request = shift;

  my $device = ($request->{'device'}) ? $request->{'device'} : undef;
  return $self->{impl}->list_device_oidsets($device);
}

sub list_oids{
  my $self = shift;
  my $request = shift;

  return $self->{impl}->list_oids();
}

sub get_oid{
  my $self = shift;
  my $request = shift;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_oid($name);
}

sub add_oid{
  my $self = shift;
  my $request = shift;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $storage = ($request->{'storage'}) ? $request->{'storage'} : undef;
  my $oidtype = ($request->{'oidtype'}) ? $request->{'oidtype'} : undef;
  return $self->{impl}->add_oid($name, $storage, $oidtype);
}

sub list_oidsets{
  my $self = shift;
  my $request = shift;

  return $self->{impl}->list_oidsets();
}

sub get_oidset{
  my $self = shift;
  my $request = shift;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_oidset($name);
}

sub get_oidset_devices{
  my $self = shift;
  my $request = shift;

  my $oidset = ($request->{'oidset'}) ? $request->{'oidset'} : undef;
  return $self->{impl}->get_oidset_devices($oidset);
}

sub get_vars_by_grouping{
  my $self = shift;
  my $request = shift;

  my $grouping = ($request->{'grouping'}) ? $request->{'grouping'} : undef;
  return $self->{impl}->get_vars_by_grouping($grouping);
}

sub store_poll_result{
  my $self = shift;
  my $request = shift;

  my $result = ($request->{'result'}) ? $request->{'result'} : undef;
  return $self->{impl}->store_poll_result($result);
}

sub select{
  my $self = shift;
  my $request = shift;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  my $begin_time = ($request->{'begin_time'}) ? $request->{'begin_time'} : undef;
  my $end_time = ($request->{'end_time'}) ? $request->{'end_time'} : undef;
  my $flags = ($request->{'flags'}) ? $request->{'flags'} : undef;
  my $cf = ($request->{'cf'}) ? $request->{'cf'} : undef;
  my $resolution = ($request->{'resolution'}) ? $request->{'resolution'} : undef;
  return $self->{impl}->select($path, $begin_time, $end_time, $flags, $cf, $resolution);
}

sub get_interfaces{
  my $self = shift;
  my $request = shift;

  my $device = ($request->{'device'}) ? $request->{'device'} : undef;
  my $all_interfaces = ($request->{'all_interfaces'}) ? $request->{'all_interfaces'} : undef;
  return $self->{impl}->get_interfaces($device, $all_interfaces);
}

package ESxSNMP::ESDBClient;

use base('ESxSNMP::ESDBIf');
sub new {
  my $classname = shift;
  my $input     = shift;
  my $output    = shift;
  my $self      = {};
    $self->{input}  = $input;
    $self->{output} = defined $output ? $output : $input;
    $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub list_devices{
  my $self = shift;
  my $active = shift;

    $self->send_list_devices($active);
  return $self->recv_list_devices();
}

sub send_list_devices{
  my $self = shift;
  my $active = shift;

  $self->{output}->writeMessageBegin('list_devices', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_list_devices_args();
  $args->{active} = $active;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_list_devices{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_list_devices_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "list_devices failed: unknown result";
}
sub get_device{
  my $self = shift;
  my $name = shift;

    $self->send_get_device($name);
  return $self->recv_get_device();
}

sub send_get_device{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_device', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_get_device_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_device{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_get_device_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_device failed: unknown result";
}
sub get_all_devices{
  my $self = shift;
  my $active = shift;

    $self->send_get_all_devices($active);
  return $self->recv_get_all_devices();
}

sub send_get_all_devices{
  my $self = shift;
  my $active = shift;

  $self->{output}->writeMessageBegin('get_all_devices', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_get_all_devices_args();
  $args->{active} = $active;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_all_devices{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_get_all_devices_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_all_devices failed: unknown result";
}
sub add_device{
  my $self = shift;
  my $name = shift;
  my $begin_time = shift;
  my $end_time = shift;

    $self->send_add_device($name, $begin_time, $end_time);
  $self->recv_add_device();
}

sub send_add_device{
  my $self = shift;
  my $name = shift;
  my $begin_time = shift;
  my $end_time = shift;

  $self->{output}->writeMessageBegin('add_device', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_add_device_args();
  $args->{name} = $name;
  $args->{begin_time} = $begin_time;
  $args->{end_time} = $end_time;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_add_device{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_add_device_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub update_device{
  my $self = shift;
  my $name = shift;
  my $begin_time = shift;
  my $end_time = shift;

    $self->send_update_device($name, $begin_time, $end_time);
  $self->recv_update_device();
}

sub send_update_device{
  my $self = shift;
  my $name = shift;
  my $begin_time = shift;
  my $end_time = shift;

  $self->{output}->writeMessageBegin('update_device', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_update_device_args();
  $args->{name} = $name;
  $args->{begin_time} = $begin_time;
  $args->{end_time} = $end_time;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_update_device{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_update_device_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub list_device_oidsets{
  my $self = shift;
  my $device = shift;

    $self->send_list_device_oidsets($device);
  return $self->recv_list_device_oidsets();
}

sub send_list_device_oidsets{
  my $self = shift;
  my $device = shift;

  $self->{output}->writeMessageBegin('list_device_oidsets', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_list_device_oidsets_args();
  $args->{device} = $device;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_list_device_oidsets{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_list_device_oidsets_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "list_device_oidsets failed: unknown result";
}
sub list_oids{
  my $self = shift;

    $self->send_list_oids();
  return $self->recv_list_oids();
}

sub send_list_oids{
  my $self = shift;

  $self->{output}->writeMessageBegin('list_oids', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_list_oids_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_list_oids{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_list_oids_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "list_oids failed: unknown result";
}
sub get_oid{
  my $self = shift;
  my $name = shift;

    $self->send_get_oid($name);
  return $self->recv_get_oid();
}

sub send_get_oid{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_oid', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_get_oid_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_oid{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_get_oid_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_oid failed: unknown result";
}
sub add_oid{
  my $self = shift;
  my $name = shift;
  my $storage = shift;
  my $oidtype = shift;

    $self->send_add_oid($name, $storage, $oidtype);
  $self->recv_add_oid();
}

sub send_add_oid{
  my $self = shift;
  my $name = shift;
  my $storage = shift;
  my $oidtype = shift;

  $self->{output}->writeMessageBegin('add_oid', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_add_oid_args();
  $args->{name} = $name;
  $args->{storage} = $storage;
  $args->{oidtype} = $oidtype;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_add_oid{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_add_oid_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub list_oidsets{
  my $self = shift;

    $self->send_list_oidsets();
  return $self->recv_list_oidsets();
}

sub send_list_oidsets{
  my $self = shift;

  $self->{output}->writeMessageBegin('list_oidsets', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_list_oidsets_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_list_oidsets{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_list_oidsets_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "list_oidsets failed: unknown result";
}
sub get_oidset{
  my $self = shift;
  my $name = shift;

    $self->send_get_oidset($name);
  return $self->recv_get_oidset();
}

sub send_get_oidset{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_oidset', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_get_oidset_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_oidset{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_get_oidset_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_oidset failed: unknown result";
}
sub get_oidset_devices{
  my $self = shift;
  my $oidset = shift;

    $self->send_get_oidset_devices($oidset);
  return $self->recv_get_oidset_devices();
}

sub send_get_oidset_devices{
  my $self = shift;
  my $oidset = shift;

  $self->{output}->writeMessageBegin('get_oidset_devices', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_get_oidset_devices_args();
  $args->{oidset} = $oidset;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_oidset_devices{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_get_oidset_devices_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_oidset_devices failed: unknown result";
}
sub get_vars_by_grouping{
  my $self = shift;
  my $grouping = shift;

    $self->send_get_vars_by_grouping($grouping);
  return $self->recv_get_vars_by_grouping();
}

sub send_get_vars_by_grouping{
  my $self = shift;
  my $grouping = shift;

  $self->{output}->writeMessageBegin('get_vars_by_grouping', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_get_vars_by_grouping_args();
  $args->{grouping} = $grouping;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_vars_by_grouping{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_get_vars_by_grouping_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_vars_by_grouping failed: unknown result";
}
sub store_poll_result{
  my $self = shift;
  my $result = shift;

    $self->send_store_poll_result($result);
  return $self->recv_store_poll_result();
}

sub send_store_poll_result{
  my $self = shift;
  my $result = shift;

  $self->{output}->writeMessageBegin('store_poll_result', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_store_poll_result_args();
  $args->{result} = $result;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_store_poll_result{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_store_poll_result_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "store_poll_result failed: unknown result";
}
sub select{
  my $self = shift;
  my $path = shift;
  my $begin_time = shift;
  my $end_time = shift;
  my $flags = shift;
  my $cf = shift;
  my $resolution = shift;

    $self->send_select($path, $begin_time, $end_time, $flags, $cf, $resolution);
  return $self->recv_select();
}

sub send_select{
  my $self = shift;
  my $path = shift;
  my $begin_time = shift;
  my $end_time = shift;
  my $flags = shift;
  my $cf = shift;
  my $resolution = shift;

  $self->{output}->writeMessageBegin('select', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_select_args();
  $args->{path} = $path;
  $args->{begin_time} = $begin_time;
  $args->{end_time} = $end_time;
  $args->{flags} = $flags;
  $args->{cf} = $cf;
  $args->{resolution} = $resolution;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_select{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_select_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{error}) {
    die $result->{error};
  }
  die "select failed: unknown result";
}
sub get_interfaces{
  my $self = shift;
  my $device = shift;
  my $all_interfaces = shift;

    $self->send_get_interfaces($device, $all_interfaces);
  return $self->recv_get_interfaces();
}

sub send_get_interfaces{
  my $self = shift;
  my $device = shift;
  my $all_interfaces = shift;

  $self->{output}->writeMessageBegin('get_interfaces', TMessageType::CALL, $self->{seqid});
  my $args = new ESxSNMP::ESDB_get_interfaces_args();
  $args->{device} = $device;
  $args->{all_interfaces} = $all_interfaces;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_interfaces{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ESxSNMP::ESDB_get_interfaces_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_interfaces failed: unknown result";
}
package ESxSNMP::ESDBProcessor;

sub new {
    my $classname = shift;
    my $handler   = shift;
    my $self      = {};
    $self->{handler} = $handler;
    return bless($self,$classname);
}

sub process {
    my $self   = shift;
    my $input  = shift;
    my $output = shift;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!method_exists($self, $methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
  }

sub process_list_devices{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ESxSNMP::ESDB_list_devices_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ESxSNMP::ESDB_list_devices_result();
    $result->{success} = $self->{handler}->list_devices($args->active);
      $output->writeMessageBegin('list_devices', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_get_device{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ESxSNMP::ESDB_get_device_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ESxSNMP::ESDB_get_device_result();
    $result->{success} = $self->{handler}->get_device($args->name);
      $output->writeMessageBegin('get_device', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_get_all_devices{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ESxSNMP::ESDB_get_all_devices_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ESxSNMP::ESDB_get_all_devices_result();
    $result->{success} = $self->{handler}->get_all_devices($args->active);
      $output->writeMessageBegin('get_all_devices', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_add_device{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ESxSNMP::ESDB_add_device_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ESxSNMP::ESDB_add_device_result();
    $self->{handler}->add_device($args->name, $args->begin_time, $args->end_time);
      $output->writeMessageBegin('add_device', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_update_device{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ESxSNMP::ESDB_update_device_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ESxSNMP::ESDB_update_device_result();
    $self->{handler}->update_device($args->name, $args->begin_time, $args->end_time);
      $output->writeMessageBegin('update_device', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_list_device_oidsets{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ESxSNMP::ESDB_list_device_oidsets_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ESxSNMP::ESDB_list_device_oidsets_result();
    $result->{success} = $self->{handler}->list_device_oidsets($args->device);
      $output->writeMessageBegin('list_device_oidsets', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_list_oids{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ESxSNMP::ESDB_list_oids_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ESxSNMP::ESDB_list_oids_result();
    $result->{success} = $self->{handler}->list_oids();
      $output->writeMessageBegin('list_oids', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_get_oid{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ESxSNMP::ESDB_get_oid_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ESxSNMP::ESDB_get_oid_result();
    $result->{success} = $self->{handler}->get_oid($args->name);
      $output->writeMessageBegin('get_oid', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_add_oid{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ESxSNMP::ESDB_add_oid_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ESxSNMP::ESDB_add_oid_result();
    $self->{handler}->add_oid($args->name, $args->storage, $args->oidtype);
      $output->writeMessageBegin('add_oid', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_list_oidsets{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ESxSNMP::ESDB_list_oidsets_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ESxSNMP::ESDB_list_oidsets_result();
    $result->{success} = $self->{handler}->list_oidsets();
      $output->writeMessageBegin('list_oidsets', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_get_oidset{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ESxSNMP::ESDB_get_oidset_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ESxSNMP::ESDB_get_oidset_result();
    $result->{success} = $self->{handler}->get_oidset($args->name);
      $output->writeMessageBegin('get_oidset', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_get_oidset_devices{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ESxSNMP::ESDB_get_oidset_devices_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ESxSNMP::ESDB_get_oidset_devices_result();
    $result->{success} = $self->{handler}->get_oidset_devices($args->oidset);
      $output->writeMessageBegin('get_oidset_devices', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_get_vars_by_grouping{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ESxSNMP::ESDB_get_vars_by_grouping_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ESxSNMP::ESDB_get_vars_by_grouping_result();
    $result->{success} = $self->{handler}->get_vars_by_grouping($args->grouping);
      $output->writeMessageBegin('get_vars_by_grouping', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_store_poll_result{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ESxSNMP::ESDB_store_poll_result_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ESxSNMP::ESDB_store_poll_result_result();
    $result->{success} = $self->{handler}->store_poll_result($args->result);
      $output->writeMessageBegin('store_poll_result', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_select{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ESxSNMP::ESDB_select_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ESxSNMP::ESDB_select_result();
    eval {
      $result->{success} = $self->{handler}->select($args->path, $args->begin_time, $args->end_time, $args->flags, $args->cf, $args->resolution);
    }; if( UNIVERSAL::isa($@,'ESDBError') ){ 
      $result->{error} = $@;
    }
    $output->writeMessageBegin('select', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->getTransport()->flush();
}
sub process_get_interfaces{
  my $self = shift;
  my ($seqid, $input, $output); 
  my $args = new ESxSNMP::ESDB_get_interfaces_args();
  $args->read($input);
  $input->readMessageEnd();
  my $result = new ESxSNMP::ESDB_get_interfaces_result();
  $result->{success} = $self->{handler}->get_interfaces($args->device, $args->all_interfaces);
    $output->writeMessageBegin('get_interfaces', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->getTransport()->flush();
}
1;
