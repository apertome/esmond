#!/usr/bin/perl
#
# Quick & dirty script to generate XML template with RRD configs for
# Sonar Measurement Archive from ESnet stats config files.
#
# Date: July 07
# This version generates the config file for the Perl Services MA
#

use strict;
use warnings;

use lib '../gen-perl';

use Net::DNS;
  

use Thrift;
use Thrift::BinaryProtocol;
use Thrift::Socket;
use Thrift::BufferedTransport;

use Data::Dumper;

use ESDB;

my $res = Net::DNS::Resolver->new;
my $DEBUG=1;

my $configfile = "/usr/local/esnet/mrtg/config/all_rtr_trfc.cfg";
my $rrddir= ""; #"/usr/local/esnet/mrtg/data/routers/traffic";
my $home=`pwd`;


my $hostname=`hostname`;
my $date=" ". localtime();

my $AUTHREALM="ESnet-Public";
my $DOMAIN="es.net";
my $HEADER=qq(<?xml version="1.0" encoding="UTF-8"?>


<!-- ===================================================================
<description>
   MA RRD configuration file

   \$Id: gen_sonar_template-PS.pl,v 1.2 2007/11/02 20:07:12 metzger Exp metzger \$
   project: perfSONAR

Notes:
   This is the configuration file which contains the information 
   about RRD files from ESnet.

   It was generated by $ENV{'USER'} on  $hostname  using $0 @ARGV
   at $date


    -Joe Metzger


</description>
==================================================================== -->
<nmwg:store
	 xmlns:nmwg="http://ggf.org/ns/nmwg/base/2.0/"
	 xmlns:netutil="http://ggf.org/ns/nmwg/characteristic/utilization/2.0/"
	 xmlns:nmwgt="http://ggf.org/ns/nmwg/topology/2.0/" 
	 xmlns:nmwgt3="http://ggf.org/ns/nmwg/topology/3.0/" >

     <!-- Note: The URNs and the nmwgt3 namespace are possible implementations, and not standard.
          The URNs should not be meta-data IDs. But maybe they should be idRefs. But this seems
	  to be expanding the scope of a reference significantly...  Joe
      -->

     <!--  metadata section  -->

);


my $bogusIP="BOGUS1";

print $HEADER;

my (%OIDSET, %NAMEIN, %NAMEOUT, %INTDESC, %DEVICE, %INTNAME, %DNS, %SPEED, %IP);
my( $in, $out, $file, $intdesc, $rtr, $intname, $ip, $dns, $speed, @ips, @dns,
    $key, $oidset, $prefix, $intpath );
#local $/; # Enable "slurp" mode

my $socket    = new Thrift::Socket('localhost', 9090);
my $transport = new Thrift::BufferedTransport($socket,1024,1024);
my $protocol  = new Thrift::BinaryProtocol($transport);
my $client    = new ESDBClient($protocol);

$socket->setRecvTimeout(2000); # 2 sec timeout
$socket->setSendTimeout(2000); # 2 sec timeout

eval {
    $transport->open();

    foreach my $device ( @{$client->list_devices(1)} ) {
        print STDERR "starting $device\n";
        my $interfaces = $client->get_interfaces($device, 0);
        foreach my $iface (@{$interfaces}) {
            if ($device eq "star-cr1") {
                print STDERR "$iface->{ifdescr}\n";
            }
            $ip = $iface->{ipaddr};
            if(defined($ip)) {
                my $answer = $res->search($ip);
                if ( defined($answer)) {
                    $dns = $answer->{answer}[0]->{ptrdname};
                } else {
                    $dns = "";
                }
            } else {
                $ip = "";
                $dns = "";
            }
    
            $rtr = $iface->{device}->{name};

            if (exists $OIDSET{$rtr}) {
                $oidset = $OIDSET{$rtr};
            } else {
                foreach my $set (@{$iface->{device}->{oidsets}}) {
                    if($set->{name} eq "FastPoll") {
                        $oidset = "FastPoll";
                        $OIDSET{$rtr} = $oidset;
                        last;
                    } elsif ($set->{name} eq "FastPollHC") {
                        $oidset = "FastPollHC";
                        $OIDSET{$rtr} = $oidset;
                        last;
                    }
                }
            }
   
            if($oidset eq "FastPollHC") {
                $prefix = "ifHC";
            } elsif ($oidset eq "FastPoll") {
                $prefix = "if";
            } else {
                print "<!-- No OIDSet for $rtr.  -->\n";
                next;
            }
                
            $intname = $iface->{ifdescr};
            $intpath = $intname;
            $intpath =~ s/\//_/g;
            $intpath =~ s/ /_/g;
            $key = "$rtr:$intname";
            $NAMEIN{$key} = $rtr . "/" . $oidset . "/";
            $NAMEIN{$key} .= $prefix . "InOctets" . "/" .  $intpath;
            $NAMEOUT{$key} = $rtr . "/" . $oidset . "/";
            $NAMEOUT{$key} .= $prefix . "OutOctets" . "/" .  $intpath;
            $INTDESC{$key} = $iface->{ifalias};
            $DEVICE{$key} = $rtr;
            $INTNAME{$key} = $intname;
            $DNS{$key} = $dns;
            if($iface->{ifhighspeed} < 1) {
                $SPEED{$key} = $iface->{ifspeed};
            } else {
                $SPEED{$key} = $iface->{ifhighspeed} * 1000000;
            }
            $IP{$key} = $ip;
        }
        print STDERR "done with $device\n";
    }
};

if($@) {
    warn(Dumper($@));
}

#
# Now need to generate XML name spaces/rnc info
#

my $META; # Contains the Meta Data
my $DATA; # Contains the data

my $i=0;
foreach $key ( sort keys %INTDESC )
{
	next unless $INTNAME{$key};

	#
	# Hack to generate small file with only fast interfaces
	#
	#next if ( $SPEED{$key} <= 1100000000 );

	$i++;

	$META .= "\n";
	$META .= qq(\t<nmwg:metadata  xmlns:nmwg="http://ggf.org/ns/nmwg/base/2.0/" id="meta$i">\n);
	$META .= qq(\t\t<netutil:subject  xmlns:netutil="http://ggf.org/ns/nmwg/characteristic/utilization/2.0/" id="subj$i">\n);
        $META .= qq(\t\t\t<nmwgt:interface xmlns:nmwgt="http://ggf.org/ns/nmwg/topology/2.0/">\n);
        $META .= qq(\t\t\t\t<nmwgt3:urn>urn:ogf:network:domain=$DOMAIN:node=$DEVICE{$key}:port=$INTNAME{$key}</nmwgt3:urn>\n);
        $META .= qq(\t\t\t\t<nmwgt:ifAddress type="ipv4">$IP{$key}</nmwgt:ifAddress>\n) unless ( $IP{$key} eq "" );
        $META .= qq(\t\t\t\t<nmwgt:hostName>$DEVICE{$key}</nmwgt:hostName>\n);
        $META .= qq(\t\t\t\t<nmwgt:ifName>$INTNAME{$key}</nmwgt:ifName>\n);
        $META .= qq(\t\t\t\t<nmwgt:ifDescription>$INTDESC{$key}</nmwgt:ifDescription>\n);
        $META .= qq(\t\t\t\t<nmwgt:capacity>$SPEED{$key}</nmwgt:capacity>\n);
        $META .= qq(\t\t\t\t<nmwgt:direction>in</nmwgt:direction>\n);
        $META .= qq(\t\t\t\t<nmwgt:authRealm>$AUTHREALM</nmwgt:authRealm>\n);
        $META .= qq(\t\t\t</nmwgt:interface>\n);
	$META .= qq(\t\t</netutil:subject>\n);
	$META .= qq(\t\t<nmwg:eventType>http://ggf.org/ns/nmwg/characteristic/utilization/2.0</nmwg:eventType>\n);
	$META .= qq(\t\t<nmwg:parameters id="metaparam$i">\n);
	$META .= qq(\t\t\t<nmwg:parameter name="supportedEventType">http://ggf.org/ns/nmwg/characteristic/utilization/2.0</nmwg:parameter>\n);
	$META .= qq(\t\t\t<nmwg:parameter name="supportedEventType">http://ggf.org/ns/nmwg/tools/snmp/2.0</nmwg:parameter>\n);
	$META .= qq(\t\t</nmwg:parameters>\n);
	$META .= qq(\t</nmwg:metadata>\n);


	$DATA .= "\n";
	$DATA .= qq(\t<nmwg:data  xmlns:nmwg="http://ggf.org/ns/nmwg/base/2.0/" id="data$i" metadataIdRef="meta$i">\n);
	$DATA .= qq(\t\t<nmwg:key id="keyid$i">\n);
	$DATA .= qq(\t\t\t<nmwg:parameters id="dataparam$i">\n);
	$DATA .= qq(\t\t\t\t<nmwg:parameter name="type">esxsnmp</nmwg:parameter>\n);
	$DATA .= qq(\t\t\t\t<nmwg:parameter name="valueUnits">Bps</nmwg:parameter>\n);
	$DATA .= qq(\t\t\t\t<nmwg:parameter name="name">$NAMEIN{$key}</nmwg:parameter>\n);
	$DATA .= qq(\t\t\t\t<nmwg:parameter name="eventType">http://ggf.org/ns/nmwg/characteristic/utilization/2.0</nmwg:parameter>\n);
	$DATA .= qq(\t\t\t</nmwg:parameters>\n);
        $DATA .= qq(\t\t</nmwg:key>\n);
	$DATA .= qq(\t</nmwg:data>\n);



	$i++;

	$META .= "\n";
	$META .= qq(\t<nmwg:metadata  xmlns:nmwg="http://ggf.org/ns/nmwg/base/2.0/" id="meta$i">\n);
	$META .= qq(\t\t<netutil:subject  xmlns:netutil="http://ggf.org/ns/nmwg/characteristic/utilization/2.0/" id="subj$i">\n);
        $META .= qq(\t\t\t<nmwgt:interface xmlns:nmwgt="http://ggf.org/ns/nmwg/topology/2.0/">\n);
        $META .= qq(\t\t\t\t<nmwgt3:urn>urn:ogf:network:domain=$DOMAIN:node=$DEVICE{$key}:port=$INTNAME{$key}</nmwgt3:urn>\n);
        $META .= qq(\t\t\t\t<nmwgt:ifAddress type="ipv4">$IP{$key}</nmwgt:ifAddress>\n) unless ( $IP{$key} eq "" );
        $META .= qq(\t\t\t\t<nmwgt:hostName>$DEVICE{$key}</nmwgt:hostName>\n);
        $META .= qq(\t\t\t\t<nmwgt:ifName>$INTNAME{$key}</nmwgt:ifName>\n);
        $META .= qq(\t\t\t\t<nmwgt:ifDescription>$INTDESC{$key}</nmwgt:ifDescription>\n);
        $META .= qq(\t\t\t\t<nmwgt:capacity>$SPEED{$key}</nmwgt:capacity>\n);
        $META .= qq(\t\t\t\t<nmwgt:direction>out</nmwgt:direction>\n);
        $META .= qq(\t\t\t\t<nmwgt:authRealm>$AUTHREALM</nmwgt:authRealm>\n);
        $META .= qq(\t\t\t</nmwgt:interface>\n);
	$META .= qq(\t\t</netutil:subject>\n);
	$META .= qq(\t\t<nmwg:eventType>http://ggf.org/ns/nmwg/characteristic/utilization/2.0</nmwg:eventType>\n);
	$META .= qq(\t\t<nmwg:parameters id="metaparam$i">\n);
	$META .= qq(\t\t\t<nmwg:parameter name="supportedEventType">http://ggf.org/ns/nmwg/characteristic/utilization/2.0</nmwg:parameter>\n);
	$META .= qq(\t\t\t<nmwg:parameter name="supportedEventType">http://ggf.org/ns/nmwg/tools/snmp/2.0</nmwg:parameter>\n);
	$META .= qq(\t\t</nmwg:parameters>\n);
	$META .= qq(\t</nmwg:metadata>\n);


	$DATA .= "\n";
	$DATA .= qq(\t<nmwg:data  xmlns:nmwg="http://ggf.org/ns/nmwg/base/2.0/" id="data$i" metadataIdRef="meta$i">\n);
	$DATA .= qq(\t\t<nmwg:key id="keyid$i">\n);
	$DATA .= qq(\t\t\t<nmwg:parameters id="dataparam$i">\n);
	$DATA .= qq(\t\t\t\t<nmwg:parameter name="type">esxsnmp</nmwg:parameter>\n);
	$DATA .= qq(\t\t\t\t<nmwg:parameter name="valueUnits">Bps</nmwg:parameter>\n);
	$DATA .= qq(\t\t\t\t<nmwg:parameter name="name">$NAMEOUT{$key}</nmwg:parameter>\n);
	$DATA .= qq(\t\t\t\t<nmwg:parameter name="eventType">http://ggf.org/ns/nmwg/characteristic/utilization/2.0</nmwg:parameter>\n);
	$DATA .= qq(\t\t\t</nmwg:parameters>\n);
        $DATA .= qq(\t\t</nmwg:key>\n);
	$DATA .= qq(\t</nmwg:data>\n);


	
} 

print $META;

print $DATA;

print qq(</nmwg:store>\n);
	
