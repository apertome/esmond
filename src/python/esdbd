#!/usr/bin/env python

import threading
from calendar import timegm

from thrift.transport import TSocket, TTransport
from thrift.protocol import TBinaryProtocol
from thrift.server import TServer

import tsdb

from essnmp.config import ESConfig
from essnmp.sql import *
from  essnmp.thrift import ESDB
import essnmp.thrift.ttypes

class ExternalInterface(threading.Thread):
    def __init__(self, **kwargs):
        Threading.Thread.__init__(self, **kwargs)
        self.setDaemon(1)
        self.workq = Queue.Queue()
        self.start()

    def request(self, *args, **kwargs):
        self.workq.put((args,kwargs))

    def run(self):
        while True:
            args, kwargs = self.workq.get()
            self.process(*args,**kwargs)

    def process(self, *args, **kwargs):
        raise NotImplementedError("subclasses MUST define process")


class StorageThread(ExternalInterface):
    def __init__(self, device_id):
        ExternalInterface.__init__(self)
        self.device_id = device_id
        self.tsdb = tsdb.TSDB(ESConfig['TSDB_ROOT'])
        self.device_set = tsdb.get_set(device_id, acquire_lock=True)
        self.vars = {}
        for var in self.device_set.list_vars():
            self.vars[var] = self.device_set.get_var(var)

    def get_var(self, name):
        try:
            return self.vars[name]
        except KeyError:
            try:
                self.vars[name] = self.device_set.get_var(name)
            except TSDBVarDoesNotExistError:
                print "adding",name

                self.vars[name] = self.device_set.add_var(name, type, step)

            return self.vars[name]

    def process(self, poll_results, **kwargs):
        for (var, val) in poll_results.vars:
            self.get_var(var).insert(poll_results.timestamp, val)

class ESDBHandler(object):
    def __init__(self):
        self.session = create_session(bind_to=essnmp.sql.db)
        self.device_threads = {}

    def list_devices(self):
        return [d.name for d in self.session.query(Device).select()]

    def get_device(self,name):
        r = self.session.query(Device).select_by(name=name)[0]
        print r.begin_time, r.end_time

        if type(r.begin_time) is not int:
            r.begin_time = timegm(r.begin_time.utctimetuple())
            if r.begin_time < 0:
                r.begin_time = 0
    
            r.end_time = timegm(r.end_time.utctimetuple())
            if r.end_time > 2**31-1:
                r.end_time = 2**31-1
            
        return r

    def get_all_devices(self):
        d = {}
        for device in self.list_devices():
            d[device] = self.get_device(device)

        return d


    def add_device(self, device):
        self.session.save(device)
        self.session.flush()

    def list_oids(self):
        return [o.name for o in self.session.query(OID).select()]

    def get_oid(self,name):
        return self.session.query(OID).select_by(name=name)[0]

    def list_oidsets(self):
        return [s.name for s in self.session.query(OIDSet).select()]

    def get_oidset(self,name):
        return self.session.query(OIDSet).select_by(name=name)[0]

    def store_poll_result(self, result):
        print "STORE"
        if self.device_threads.has_key(result.device_id):
            self.device_threads[result.device_id].request(result)
        return 1

handler = ESDBHandler()
processor = ESDB.Processor(handler)
transport = TSocket.TServerSocket(9090)
tfactory = TTransport.TBufferedTransportFactory()
pfactory = TBinaryProtocol.TBinaryProtocolFactory()

server = TServer.TThreadedServer(processor, transport, tfactory, pfactory)

server.serve()
