#!/usr/bin/env python

"""
esmond-ps-pipe - take piped json output from bwctl and load into an esmond 
perfsonar MA. To wit:

bwctl -c lbl-pt1.es.net -s llnl-pt1.es.net -T iperf3 --parsable | esmond-ps-pipe -url http://ps-archive.es.net
"""

import datetime
import json
import logging
import os
import sys
import time

from optparse import OptionParser

class EsmondPipeException(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class EsmondPipeWarning(Warning): pass

def setup_log(log_path=None):
    """
    Usage:
    _log('main.start', 'happy simple log event')
    _log('launch', 'more={0}, complex={1} log=event'.format(100, 200))
    """
    log = logging.getLogger("esmond-ps-pipe")
    if not log_path:
        _h = logging.StreamHandler()
    else:
        # it's on you to make sure log_path is valid.
        logfile = '{0}/esmond-ps-pipe.log'.format(log_path)
        _h = logging.FileHandler(logfile)
    _h.setFormatter(logging.Formatter('ts=%(asctime)s %(message)s'))
    log.addHandler(_h)
    log.setLevel(logging.INFO)
    return log

class RecursiveDataObject(object):
    def __init__(self, initial=None):
        self.__dict__['_data'] = {}

        if hasattr(initial, 'items'):
            self.__dict__['_data'] = initial
            try:
                # Recurse through entire all attrs at all levels
                # to make sure the wrapping is ok so we can check
                # the parse once.
                for i in self._data.keys():
                    self._wrap(self._data.get(i), i)
            except Exception as e:
                raise EsmondPipeException(str(e))

    def _wrap(self, data, name):
        # print 'wrap', name
        # dict => wrapper object
        if isinstance(data, dict):
            return RecursiveDataObject(data)
        # list of dicts => list of wrapper objects
        elif isinstance(data, list):
            return [ RecursiveDataObject(x) for x in data ]
        # modify outgoing named attributes
        elif name in ('time','timesecs',):
            return self._to_datetime(data)

        return data

    def _to_datetime(self, d):
        if isinstance(d, int):
            # presume unixtime
            return datetime.datetime.utcfromtimestamp(d)
        else:
            return datetime.datetime.strptime(d, '%a, %d %b %Y %X GMT')

    def __getattr__(self, name):
        return self._wrap(self._data.get(name, None), name)

    def __setattr__(self, name, value):
        self.__dict__['_data'][name] = value

    def to_dict(self):
        return self._data

def id_and_extract(data, _log):
    """
    Identify the piped input and isolate the json part.
    """

    class Payload(object):
        input_type = None
        payload = None

    payload = Payload()

    input_type = None
    json_block = ''

    scanning = False

    for i in data:
        if not i.strip():
            continue

        if i.startswith('bwctl: Using tool:'):
            input_type = i.split()[3]

        if i.startswith('SENDER END'):
            scanning = False
            break

        if scanning:
            json_block += i

        if i.startswith('SENDER START'):
            scanning = True

    if not input_type:
        _log('id_and_extract.error', 'could not extract test type.')
    else:
        payload.input_type = input_type

    try:
        payload.payload = json.loads(json_block)
    except ValueError:
        _log('id_and_extract.error', 'could not load json_block: {0}'.format(json_block))

    if not payload.payload or not payload.input_type:
        return None
    else:
        return payload

def process_iperf3(o, _log):
    _log('process_iperf3.start', 'begin')



    _log('process_iperf3.end', 'finished')


typemap = dict(
    iperf3=process_iperf3,
)

def main():
    usage = ' bwctl ... | %prog [ -u USER -k API_KEY | -U ESMOND_REST_URL | -v ]'
    parser = OptionParser(usage=usage)
    parser.add_option('-U', '--url', metavar='ESMOND_REST_URL',
            type='string', dest='api_url', 
            help='URL for the REST API (default=%default) - required.',
            default='http://localhost:8000')
    parser.add_option('-u', '--user', metavar='USER',
            type='string', dest='user', default='',
            help='POST interface username.')
    parser.add_option('-k', '--key', metavar='API_KEY',
            type='string', dest='key', default='',
            help='API key for POST operation.')
    parser.add_option('-v', '--verbose',
        dest='verbose', action='store_true', default=False,
        help='Verbose output.')
    parser.add_option('-l', '--log_dir', metavar='DIR',
                type='string', dest='logdir', default='',
                help='Write log output to specified directory - if not set, log goes to stdout.')
    options, args = parser.parse_args()

    log_path = None
    
    if options.logdir:
        log_path = os.path.normpath(options.logdir)
        if not os.path.exists(log_path):
            parser.error('{0} log path does not exist.'.format(log_path))
    
    log = setup_log(log_path)
    _log = lambda e, s: log.info('event={e} id={gid} {s}'.format(e=e, gid=int(time.time()), s=s))

    if not options.user or not options.key:
        parser.error('both --user and --key args are required.')

    data = sys.stdin.readlines()
    
    payload = id_and_extract(data, _log)

    if not payload:
        _log('main.fatal', 'could not extract type and valid json from input')
        _log('main.debug', '{0}'.format(''.join(data)))
        _log('main.fatal', 'exiting')
        sys.exit(-1)

    try:
        o = RecursiveDataObject(payload.payload)
    except EsmondPipeException as e:
        _log('main.fatal', 'error encapsulating json - ERROR: {0}'.format(str(e)))
        _log('main.fatal', 'exiting')
        sys.exit(-1)

    # process the encapsulated data
    try:
        typemap[payload.input_type](o, _log)
    except KeyError:
        _log('main.fatal', 'there is no handler for input type: {0}'.format(payload.input_type))
        _log('main.fatal', 'exiting')
    except EsmondPipeException as e:
        _log('main.error', 'unable to process input: {0}'.format(str(e)))

    sys.exit(0)

if __name__ == '__main__':
    main()